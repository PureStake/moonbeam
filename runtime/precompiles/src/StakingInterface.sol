// SPDX-License-Identifier: GPL-3.0-only

// @nanocryk I've copied over the doc comments from the pallet. Is that useful to solidity devs?
// Like specifically, will their IDEs show those docs or something? Otherwise, not worth copying.

pragma solidity >=0.8.0;

/// The interface through which solidity contracts will interact with Parachain Staking
/// We follow this same interface including four-byte function selectors, in the precompile that
/// wraps the pallet
interface ParachainStaking {
    // First some simple accessors

    /// Check whether the specified address is currently a staking nominator
    function is_nominator(address nominator) external view returns (bool);

    /// Check whether the specified addess is currently a collator candidate
    function is_candidate(address collator) external view returns (bool);

    /// Check whether the specified address is an active collator
    function is_selected_candidate(address collator)
        external
        view
        returns (bool);

    /// Commission percent taken off of rewards for all collators
    // TODO Skipping Rust implementation for now because I don't know how to express
    // the fixed point type.
    function collator_commission() external view returns (bool); //TODO wrong return type

    /// The total number candidates selected every round
    function total_selected() external view returns (uint256);

    /// The pool of collator candidates, each with their total backing stake
    // The return type might get hariy here too. Maybe this answer will help?
    // https://ethereum.stackexchange.com/a/74334/9963
    function candidate_pool() external view returns (address[] memory);

    /// The queue of collators waiting to exit
    function exit_queue() external view returns (address[] memory);

    /// Snapshot of collator nomination stake at the start of the round
    function at_stake(uint256 roundIndex, address target)
        external
        view
        returns (uint256);

    /// Total backing stake for selected candidate as of right now
    function staked(address target) external view returns (uint256);

    /// The current inflation configuration
    // TODO do we want to do this? It returns a custom struct. Maybe we could have seperate
    // accessors for each part of it?
    function inflation_config() external view returns (bool); //TODO wrong return type

    /// Total points awarded to all collators for block production so far in the current round
    function points(uint256 roundIndex) external view returns (uint256);

    // Now the dispatchables

    /// Join the set of collator candidates
    function join_candidates(uint256 amount) external;

    /// Request to leave the set of candidates. If successful, the account is immediately
    /// removed from the candidate pool to prevent selection as a collator, but unbonding is
    /// executed with a delay of `BondDuration` rounds.
    function leave_candidates() external;

    /// Temporarily leave the set of collator candidates without unbonding
    function go_offline() external;

    /// Rejoin the set of collator candidates if previously had called `go_offline`
    function go_online() external;

    /// Bond more for collator candidates
    function candidate_bond_more(uint256 more) external;

    /// Bond less for collator candidates
    function candidate_bond_less(uint256 less) external;

    /// If caller is not a nominator, then join the set of nominators
    /// If caller is a nominator, then makes nomination to change their nomination state
    function nominate(address collator, uint256 amount) external;

    /// Leave the set of nominators and, by implication, revoke all ongoing nominations
    function leave_nominators() external;

    /// Revoke an existing nomination
    function revoke_nomination(address collator) external;

    /// Bond more for nominators with respect to a specific collator candidate
    function nominator_bond_more(address candidate, uint256 more) external;

    /// Bond less for nominators with respect to a specific nominator candidate
    function nominator_bond_less(address candidate, uint256 less) external;
}

// These are the selectors generated by remix following this advice
// https://ethereum.stackexchange.com/a/73405/9963
// Eventually we will probably want a better way of generating these and copying them to Rust
// {
// 	"42a72461": "at_stake(uint256,address)",
// 	"289b6ba7": "candidate_bond_less(uint256)",
// 	"c57bd3a8": "candidate_bond_more(uint256)",
// 	"96b41b5b": "candidate_pool()",
// 	"b0c0081f": "collator_commission()",
// 	"427c3c14": "exit_queue()",
// 	"767e0450": "go_offline()",
// 	"d2f73ceb": "go_online()",
// 	"10db2de9": "inflation_config()",
// 	"8545c833": "is_candidate(address)",
// 	"8e5080e7": "is_nominator(address)",
// 	"8f6d27c7": "is_selected_candidate(address)",
// 	"ad76ed5a": "join_candidates(uint256)",
// 	"b7694219": "leave_candidates()",
// 	"e8d68a37": "leave_nominators()",
// 	"82f2c8df": "nominate(address,uint256)",
// 	"f6a52569": "nominator_bond_less(address,uint256)",
// 	"971d44c8": "nominator_bond_more(address,uint256)",
// 	"9799b4e7": "points(uint256)",
// 	"4b65c34b": "revoke_nomination(address)",
// 	"98807d84": "staked(address)",
// 	"7b46e61b": "total_selected()"
// }
